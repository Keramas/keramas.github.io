---
layout: post
title: 'The Time I Chased a Cab (File): Zip Slip and Certificate Cloning'
date: '2019-09-21T22:41:00.000-07:00'
author: Keramas
tags: 
modified_time: '2019-09-28T21:36:20.951-07:00'
thumbnail: https://1.bp.blogspot.com/-oUL2s67Br6M/XYcAc-_9hSI/AAAAAAAABCE/rFulmKMHi8MHziicgwwnsvM3-56MaltbQCEwYBhgL/s72-c/cab_create.png
blogger_id: tag:blogger.com,1999:blog-4206503528938574504.post-7401634047086311597
blogger_orig_url: https://k3ramas.blogspot.com/2019/09/the-time-i-chased-cab-file-zip-slip-and.html
---

While doing research for a pretty large and complicated thick client assessment recently, I ended up diving down a rabbit hole involving cabinet files (.cab) as I noticed the application performing some interesting sequential functions.<br /><br />In a nutshell, the application would do the following with elevated processes:<br /><ol><li>Retrieve a cab file</li><li>Extract the cab file</li><li>Run an application-specific executable&nbsp;</li></ol>This blog entry will focus on two different aspects of cabinet files that aided in exploiting the above functionality to spawn a reverse shell:<br /><ul><li>Susceptibility to 'Zip Slip'</li><li>Cloning cab file certificates</li></ul><h3>What is a .cab file?</h3>A .cab file, short for 'cabinet' file is a special archive format for Windows. They are often used for updating applications, system drivers, and other fun stuff.[1]<br /><h3>Hacker mentality 101: "What would happen if..."</h3>While I had absolutely no knowledge about these files, as soon as I saw 'archive', spidey senses started to tingle and I started to wonder if cab files could be susceptible to "Zip Slip"[2]: arbitrary file writes due to archive extraction typically associated with zip files.<br /><br />I did not see any explicit reports of cab files being affected by this vulnerability, so I decided to give it a shot and created a test cab file to see if this was possible.<br /><br />I created a new cab file using lcab[3], which contained a valid file name as well as file that had a directory traversal as the file name.<br /><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-oUL2s67Br6M/XYcAc-_9hSI/AAAAAAAABCE/rFulmKMHi8MHziicgwwnsvM3-56MaltbQCEwYBhgL/s1600/cab_create.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="235" data-original-width="893" height="168" src="https://1.bp.blogspot.com/-oUL2s67Br6M/XYcAc-_9hSI/AAAAAAAABCE/rFulmKMHi8MHziicgwwnsvM3-56MaltbQCEwYBhgL/s640/cab_create.png" width="640" /></a></div>Investigating the code of the thick client, I found that it was using a DLL called "Microsoft.Deployment.Compression DLL", which I discovered is part of the WiX Toolset by FireGiant.<br /><br />Analyzing the function for extraction, I&nbsp; saw that it takes the full file name and simply concatenates it with the destination path. As there is no sanitization or validation occurring, a file named with a directory traversal string (like I generated) should theoretically be extracted to the path indicated in the directory traversal.<br /><!-- HTML generated using hilite.me --><br /><div style="background: #272822; border-width: 0.1em 0.1em 0.1em 0.8em; border: solid gray; overflow: auto; padding: 0.2em 0.6em; width: auto;"><pre style="line-height: 125%; margin: 0;"><span style="color: #75715e;">// Microsoft.Deployment.Compression.ArchiveInfo</span><br /><span style="color: #75715e;">// Token: 0x0600002C RID: 44 RVA: 0x00002700 File Offset: 0x00001700</span><br /><span style="color: #66d9ef;">public</span> <span style="color: #66d9ef;">void</span> <span style="color: #a6e22e;">Unpack</span><span style="color: #f8f8f2;">(</span><span style="color: #66d9ef;">string</span> <span style="color: #f8f8f2;">destDirectory,</span> <span style="color: #f8f8f2;">EventHandler&lt;ArchiveProgressEventArgs&gt;</span> <span style="color: #f8f8f2;">progressHandler)</span><br /><span style="color: #f8f8f2;">{</span><br /> <span style="color: #66d9ef;">using</span> <span style="color: #f8f8f2;">(CompressionEngine</span> <span style="color: #f8f8f2;">compressionEngine</span> <span style="color: #f8f8f2;">=</span> <span style="color: #66d9ef;">this</span><span style="color: #f8f8f2;">.CreateCompressionEngine())</span><br /> <span style="color: #f8f8f2;">{</span><br />  <span style="color: #f8f8f2;">compressionEngine.Progress</span> <span style="color: #f8f8f2;">+=</span> <span style="color: #f8f8f2;">progressHandler;</span><br />  <span style="color: #f8f8f2;">compressionEngine.Unpack(</span><span style="color: #66d9ef;">new</span> <span style="color: #f8f8f2;">ArchiveFileStreamContext(</span><span style="color: #66d9ef;">this</span><span style="color: #f8f8f2;">.FullName,</span> <span style="color: #f8f8f2;">destDirectory,</span> <span style="color: #66d9ef;">null</span><span style="color: #f8f8f2;">)</span><br />  <span style="color: #f8f8f2;">{</span><br />   <span style="color: #f8f8f2;">EnableOffsetOpen</span> <span style="color: #f8f8f2;">=</span> <span style="color: #66d9ef;">true</span><br />  <span style="color: #f8f8f2;">},</span> <span style="color: #66d9ef;">null</span><span style="color: #f8f8f2;">);</span><br /> <span style="color: #f8f8f2;">}</span><br /><span style="color: #f8f8f2;">}</span><br /></pre></div><br />I took the code that was hypothesized to be vulnerable and created a basic C# application to perform an extraction test.<br /><!-- HTML generated using hilite.me --><br /><div style="background: #272822; border-width: 0.1em 0.1em 0.1em 0.8em; border: solid gray; overflow: auto; padding: 0.2em 0.6em; width: auto;"><pre style="line-height: 125%; margin: 0;"><span style="color: #66d9ef;">using</span> <span style="color: #f8f8f2;">System;</span><br /><span style="color: #66d9ef;">using</span> <span style="color: #f8f8f2;">System.Collections.Generic;</span><br /><span style="color: #66d9ef;">using</span> <span style="color: #f8f8f2;">System.Linq;</span><br /><span style="color: #66d9ef;">using</span> <span style="color: #f8f8f2;">System.Text;</span><br /><span style="color: #66d9ef;">using</span> <span style="color: #f8f8f2;">System.IO;</span><br /><span style="color: #66d9ef;">using</span> <span style="color: #f8f8f2;">System.Threading.Tasks;</span><br /><span style="color: #66d9ef;">using</span> <span style="color: #f8f8f2;">Microsoft.Deployment.Compression;</span><br /><span style="color: #66d9ef;">using</span> <span style="color: #f8f8f2;">Microsoft.Deployment.Compression.Cab;</span><br /><br /><br /><span style="color: #66d9ef;">namespace</span> <span style="color: #f8f8f2;">CabSlip</span><br /><span style="color: #f8f8f2;">{</span><br />    <span style="color: #66d9ef;">class</span> <span style="color: #a6e22e;">Program</span><br />    <span style="color: #f8f8f2;">{</span><br />        <span style="color: #66d9ef;">static</span> <span style="color: #66d9ef;">void</span> <span style="color: #a6e22e;">Main</span><span style="color: #f8f8f2;">(</span><span style="color: #66d9ef;">string</span><span style="color: #f8f8f2;">[]</span> <span style="color: #f8f8f2;">args)</span><br />        <span style="color: #f8f8f2;">{</span><br />            <span style="color: #66d9ef;">if</span> <span style="color: #f8f8f2;">(args.Length</span> <span style="color: #f8f8f2;">==</span> <span style="color: #ae81ff;">0</span><span style="color: #f8f8f2;">)</span><br />            <span style="color: #f8f8f2;">{</span><br />                <span style="color: #f8f8f2;">Console.WriteLine(</span><span style="color: #e6db74;">"Usage: &lt;cab file&gt; &lt;dst dir&gt;"</span><span style="color: #f8f8f2;">);</span><br />                <span style="color: #66d9ef;">return</span><span style="color: #f8f8f2;">;</span><br />            <span style="color: #f8f8f2;">}</span><br />            <span style="color: #f8f8f2;">Console.WriteLine(</span><span style="color: #e6db74;">"Cab extraction test for zip slip."</span><span style="color: #f8f8f2;">);</span><br /><br />            <span style="color: #66d9ef;">string</span> <span style="color: #f8f8f2;">fileName</span> <span style="color: #f8f8f2;">=</span> <span style="color: #f8f8f2;">args[</span><span style="color: #ae81ff;">0</span><span style="color: #f8f8f2;">];</span><br />            <span style="color: #66d9ef;">string</span> <span style="color: #f8f8f2;">destination</span> <span style="color: #f8f8f2;">=</span> <span style="color: #f8f8f2;">args[</span><span style="color: #ae81ff;">1</span><span style="color: #f8f8f2;">];</span><br /><br />            <span style="color: #f8f8f2;">Console.WriteLine(</span><span style="color: #e6db74;">"Extracting "</span> <span style="color: #f8f8f2;">+</span> <span style="color: #f8f8f2;">fileName</span> <span style="color: #f8f8f2;">+</span> <span style="color: #e6db74;">" to "</span> <span style="color: #f8f8f2;">+</span> <span style="color: #f8f8f2;">destination);</span><br /><br />            <span style="color: #66d9ef;">new</span> <span style="color: #a6e22e;">CabInfo</span><span style="color: #f8f8f2;">(fileName).Unpack(destination);</span>            <br />            <br /><br />        <span style="color: #f8f8f2;">}</span><br />    <span style="color: #f8f8f2;">}</span><br /><span style="color: #f8f8f2;">}</span><br /></pre></div><br />After running this in conjunction with my malicious cab file, I confirmed that it was indeed susceptible to Zip Slip.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-2CFJ95X-opI/XYcAbLO-v9I/AAAAAAAABCA/4V73UU6UmJk_g9QJBsxvDNG3Pt-svnCKgCEwYBhgL/s1600/dll_zip_slip_test.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="1008" data-original-width="967" height="640" src="https://1.bp.blogspot.com/-2CFJ95X-opI/XYcAbLO-v9I/AAAAAAAABCA/4V73UU6UmJk_g9QJBsxvDNG3Pt-svnCKgCEwYBhgL/s640/dll_zip_slip_test.png" width="613" /></a></div><br />Switching back to the thick client, I put some breakpoints in dnSpy so I could swap in my malicious cab file to verify that this could be replicated, and after continuing code execution--it worked--the cab file was extracted and I successfully wrote a file to C:\windows\system32.<br /><br />The vulnerability in the DLL was reported to FireGiant, and it has been remediated as referenced in <a href="https://nvd.nist.gov/vuln/detail/CVE-2019-16511">CVE-2019-16511</a>.[4]<br /><h3>Rain falling on the parade</h3>This was when I started to get quite excited that I might have something interesting to play with, but when I tried to have the application run through everything without any breakpoints set, my cab file was being rejected.<br /><br />To my dismay, multiple protection checks were put in place to ensure the integrity of the cab file that was going to be extracted was maintained:<br /><ul><li>Digital signature verification</li><li>Certificate authority chain validation</li><li>CN name check on certificate</li></ul>The checkpoint that hurt the most was the chain validation as this was from a X509 Windows API call that was reaching out for several confirmations that the chain was valid and the certificate was not revoked.<br /><br />While Sigthief [5] exists for cloning signatures and injecting them into portable executables, no methods or tools existed for doing the same for cab files, and I wasn't ready to give up on this exploit chain just yet, so I decided it was time to explore how cab files are constructed at the byte level to see if cloning the signature was possible.<br /><h3>Forging Certificates&nbsp;</h3>Luckily, certificates are just appended to the end of the actual cab file data, and by reading the documentation on how cab file headers are constructed, I discovered that it was possible to clone certificates onto cab files by switching byte values in the header.<br /><br />By calculating offsets to data and cloning certain special bytes from the cab file whose certificate is the target, the header can be reconstructed to fit the data of a new, malicious cab file.<br /><br />Example cab file header:<br /><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-xIW7CRfRp4I/XYcJVem7l1I/AAAAAAAABCU/YeCpnHAqOhUT-DnkByWDFrF8uSZWu5EdgCLcBGAsYHQ/s1600/cab_breakdown.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="183" data-original-width="746" height="156" src="https://1.bp.blogspot.com/-xIW7CRfRp4I/XYcJVem7l1I/AAAAAAAABCU/YeCpnHAqOhUT-DnkByWDFrF8uSZWu5EdgCLcBGAsYHQ/s640/cab_breakdown.png" width="640" /></a></div>While I will not go into the full nitty-gritty on each and every byte that needs to be cloned and/or modified (Feel free to read the documentation and my tool comments though for a bit more information!), the labeled portions are most of the key areas that need to be calculated or cloned from the original source cab file.<br /><br />A.&nbsp; Offset to certificate data<br />B.&nbsp; Length of the file included in the archive<br />C.&nbsp; Extra data flag, which indicates there is a certificate at the end<br />D.&nbsp; Start of data<br />E.&nbsp; Check sum (in most cases this can be arbitrary)<br />F.&nbsp; Size of uncompressed and compressed data in the archive. (This has a maximum of 0x8000, and when a file is bigger than this, the file is chunked, and this value is an offset to the next chunk.)<br /><br />With the above in mind, I developed the "Cab Cloning Factory" tool which allows for the cloning of cab file certificates.<br /><br />Github link:<br /><a href="https://github.com/Keramas/CabCloningFactory">https://github.com/Keramas/CabCloningFactory</a><br /><br />This allowed me to create a cab file with a reverse shell payload that bypassed all of the certificate protection checks mentioned in the previous section, and ultimately get a shell with elevated privileges by overwriting the executable that would subsequently be executed after the cab files extraction process completed.<br /><h3>Conclusion</h3>This came about due to my stubbornness to not give up on exploiting what I found. Spending a sleepless night or two for research and development to get this going was well worth it. It was a lot of trial and error, and while the generic cloning tool is not quite 100% yet, I hope others take a look and find it useful. I am curious to see how many times I run into cab files moving forward...<br /><br />With all of that said, the takeaway is that signature and certificate checks are not a panacea for ensuring data integrity, and this should be kept in mind for applications using these types of validations for protection.<br /><h4>References:</h4>[1]<a href="https://en.wikipedia.org/wiki/Cabinet_(file_format)">https://en.wikipedia.org/wiki/Cabinet_(file_format)</a><br />[2]<a href="https://snyk.io/research/zip-slip-vulnerability">https://snyk.io/research/zip-slip-vulnerability</a><br />[3]<a href="http://manpages.ubuntu.com/manpages/bionic/man1/lcab.1.html">http://manpages.ubuntu.com/manpages/bionic/man1/lcab.1.html</a><br />[4]<a href="https://www.firegiant.com/blog/2019/9/18/wix-v3.11.2-released/">https://www.firegiant.com/blog/2019/9/18/wix-v3.11.2-released/</a><br />[5]<a href="https://github.com/secretsquirrel/SigThief">https://github.com/secretsquirrel/SigThief</a><br /><h4>Vulnerability disclosure timeline:</h4>Disclosure to Firegiant for WiX Toolset -&nbsp;<b>8/23</b><br />Received reply from Firegiant -&nbsp;<b>8/23</b><br />Vulnerability remediated by FireGiant and publicized - <b>9/18</b><br />WiX Toolset vulnerability confirmed as CVE-2019-16511 - <b>9/18</b><br /><br /><br /><br /><br /><br /><br />