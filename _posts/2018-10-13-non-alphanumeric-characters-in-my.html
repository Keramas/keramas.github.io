---
layout: post
title: Non-alphanumeric characters in my alphanumeric encoded payload - Exploration
  with NNM 7.53
date: '2018-10-13T20:07:00.002-07:00'
author: Keramas
tags: 
modified_time: '2018-10-13T20:09:29.334-07:00'
thumbnail: https://1.bp.blogspot.com/-DkHE3hJjQJI/W8KxkhZzbZI/AAAAAAAAArs/w8hiJ_3GTcUFXz9gWV1mb3qD-U3n2jVnQCEwYBhgL/s72-c/nnm_payloadtruncate2.png
blogger_id: tag:blogger.com,1999:blog-4206503528938574504.post-3239284581253909149
blogger_orig_url: https://k3ramas.blogspot.com/2018/10/non-alphanumeric-characters-in-my.html
---

After watching the Defcon 16 talk by Muts in regard to the 0-day they discovered in the NNM service and how they overcame all the crazy obstacles they were faced with, I wanted to learn more about this and explore it in-depth.<br /><br />DEFCON 16: BackTrack Foo - From bug to 0day:<br /><div><a href="https://www.youtube.com/watch?v=gHISpAZiAm0">https://www.youtube.com/watch?v=gHISpAZiAm0</a></div><div><br /></div>Original PoC:<br /><a href="https://www.offensive-security.com/0day/hp-nnm-ov.py.txt">https://www.offensive-security.com/0day/hp-nnm-ov.py.txt</a><br /><br />While I will not be doing a full walkthrough of the exploit process as it is explained in depth in the DC16 talk (I highly recommend watching the video!) as well as other articles, I just wanted to share some learning that took place during my studies.<br /><br />To summarize the difficulties of writing this exploit, while it appeared to be a simple SEH overwrite, it became much more complicated due to a severely restricted character set. This means:<br /><br />-Need to find a POP POP RET address that conforms to only the characters that can be used.<br />-Cannot use an egghunter as it is. It will need to be encoded.<br /><br />The encoding process is essentially witchcraft, and there is a great explanation on the process by Vellosec:<br /><a href="https://vellosec.net/2018/08/carving-shellcode-using-restrictive-character-sets/">https://vellosec.net/2018/08/carving-shellcode-using-restrictive-character-sets/</a><br /><br />Based on this encoding technique, I created a script to facilitate the encoding process when using Matt Miller's 32 byte egghunter shellcode:<br /><a href="https://github.com/Keramas/EgghunterShellcodeCarver">https://github.com/Keramas/EgghunterShellcodeCarver</a><br /><br />In order to study this exploit, I spun up a Windows 2003 SP2 server and found an ISO for NNM. However, I discovered that the version I found and installed was version 7.53, which was not the exact version in the original PoC.<br /><br />Using the following script based off of the PoC, there was an issue after execution was redirected to my reverse shell shellcode.<br /><br /><script src="https://gist.github.com/Keramas/15d5985b61e5dae0c98f67689307800c.js"></script><br /><br />In the original PoC, a bind shell payload was delivered at the very end of the GET request. However, in version 7.53, this is not possible as the length of the data sent at the end of the request is checked and limited to around 150 bytes in length, which is not nearly long enough for an encoded payload.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-DkHE3hJjQJI/W8KxkhZzbZI/AAAAAAAAArs/w8hiJ_3GTcUFXz9gWV1mb3qD-U3n2jVnQCEwYBhgL/s1600/nnm_payloadtruncate2.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="487" data-original-width="417" height="400" src="https://1.bp.blogspot.com/-DkHE3hJjQJI/W8KxkhZzbZI/AAAAAAAAArs/w8hiJ_3GTcUFXz9gWV1mb3qD-U3n2jVnQCEwYBhgL/s400/nnm_payloadtruncate2.png" width="342" /></a></div><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://3.bp.blogspot.com/-s-L9CIQIMHo/W8KxlGUU62I/AAAAAAAAArw/nQ9NkRaxJKsAICcIFmYg7HA4phAAAgeRgCEwYBhgL/s1600/nnm_truncatedpayload.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="150" data-original-width="447" height="214" src="https://3.bp.blogspot.com/-s-L9CIQIMHo/W8KxlGUU62I/AAAAAAAAArw/nQ9NkRaxJKsAICcIFmYg7HA4phAAAgeRgCEwYBhgL/s640/nnm_truncatedpayload.png" width="640" /></a></div><br /><br />The payload at the end did not have to follow the same restricted character set, but now it is not possible to place a payload there. It now needs to be moved somewhere into the forefront of the buffer, and it needs to adhere to the strict character rules.<br /><br />Alphanumeric shellcode to the rescue! Or so I thought...<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://2.bp.blogspot.com/-HqbafHZDAYM/W8KxjWz_-dI/AAAAAAAAArc/fsEP-QTU4KguTApqEMeaDkI_sWTyr4bAwCEwYBhgL/s1600/nnm_alphanumpresent.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="240" data-original-width="1310" height="116" src="https://2.bp.blogspot.com/-HqbafHZDAYM/W8KxjWz_-dI/AAAAAAAAArc/fsEP-QTU4KguTApqEMeaDkI_sWTyr4bAwCEwYBhgL/s640/nnm_alphanumpresent.png" width="640" /></a></div><br /><br />Uh, those aren't alphanumeric, msfvenom. What gives? When using msfvenom to create an alphanumeric payload, the first couple of bytes are actually not alphanumeric. This is because these bytes are "<span style="background-color: white; color: #666666; font-family: &quot;open sans&quot; , sans-serif; font-size: 15px;">needed in order to find the payloads absolute location in memory and obtain a fully position-independent shellcode"</span>. Due to this, we can't use this payload as-is because these bytes are not in the good character set, and it will disrupt the exploit.<br /><br />Well, we can just encode it using the same SUB encoding method used for the egghunter shellcode to carve this shellcode into EAX, but there is a better way which results in less of a headache.<br /><br />Luckily msfvenom has an argument that can be used to eliminate this as long as we know the exact address where our shellcode begins. (Source:&nbsp;<a href="https://www.offensive-security.com/metasploit-unleashed/alphanumeric-shellcode/">https://www.offensive-security.com/metasploit-unleashed/alphanumeric-shellcode/</a>)<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://2.bp.blogspot.com/-2BBYQlf5AEg/W8KxkFzD9BI/AAAAAAAAAro/JLfAXOsJKH4QsfUDC2XilOuPpNBSXbLpgCEwYBhgL/s1600/nnm_msfvenomblurb.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="128" data-original-width="837" height="96" src="https://2.bp.blogspot.com/-2BBYQlf5AEg/W8KxkFzD9BI/AAAAAAAAAro/JLfAXOsJKH4QsfUDC2XilOuPpNBSXbLpgCEwYBhgL/s640/nnm_msfvenomblurb.png" width="640" /></a></div><br /><br />Let's look at the instructions for Matt Miller's egghunter code.<br /><br />You'll notice that once the egg is found, the final instruction is JMP EDI.<br /><br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-ScpSLV4wyeo/W8Kxj1pUnNI/AAAAAAAAAsA/UjhjE-cckDsS4tW0XdQ96zciZeuEJaNAQCEwYBhgL/s1600/nnm_jmpedi.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="221" data-original-width="493" height="284" src="https://1.bp.blogspot.com/-ScpSLV4wyeo/W8Kxj1pUnNI/AAAAAAAAAsA/UjhjE-cckDsS4tW0XdQ96zciZeuEJaNAQCEwYBhgL/s640/nnm_jmpedi.png" width="640" /></a></div><br /><br />Since we know that the beginning of our shellcode will be at the address where EDI points to, we can tell msfvenom this by using the following syntax in our command:<br /><br /><i><b>BufferRegister=EDI</b></i><br /><br />This removes the need to add those non-alphanumeric characters to the beginning of our payload, and our payload can then be 100% alphanumeric.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://4.bp.blogspot.com/-NQR1h2WWmQs/W8KxjelNkEI/AAAAAAAAAr8/0zKkrVVw8m8JxWNf0sFpprixD-eNURDPgCEwYBhgL/s1600/nnm_alphanum_notpresent.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="238" data-original-width="1485" height="102" src="https://4.bp.blogspot.com/-NQR1h2WWmQs/W8KxjelNkEI/AAAAAAAAAr8/0zKkrVVw8m8JxWNf0sFpprixD-eNURDPgCEwYBhgL/s640/nnm_alphanum_notpresent.png" width="640" /></a></div><br /><br />Modifying the script, we can put the egg and our reverse shell shellcode into the beginning of our buffer, which results in a successful reverse shell being sent back to the attacker machine.<br /><br /><script src="https://gist.github.com/Keramas/5c069028b2cc5f828aacff99b86d9be6.js"></script><br /><br />Once the egghunter locates our egg, it jumps to EDI, which is where our reverse shell shellcode is located at the very beginning of our crash buffer. The payload is composed of allowable characters, and runs smoothly kicking us back a reverse shell.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://3.bp.blogspot.com/-4BBgoCeccfs/W8KxjacRkoI/AAAAAAAAAr0/DKr_MDVgbBsTIidgKmRbEfKYBN9cgWiVACEwYBhgL/s1600/nnm_goodpayload.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="756" data-original-width="1600" height="302" src="https://3.bp.blogspot.com/-4BBgoCeccfs/W8KxjacRkoI/AAAAAAAAAr0/DKr_MDVgbBsTIidgKmRbEfKYBN9cgWiVACEwYBhgL/s640/nnm_goodpayload.png" width="640" /></a></div><br /><br /><b>Conclusion &amp; takeaway:</b><br />When using an egghunter such as Matt Miller's, it is possible to easily use a fully alphanumeric encoded msfvenom payload by specifying that the shellcode start is located at EDI.<br /><br />While this may be common knowledge, I spent a lot of time yesterday working on this exploit by myself and discovering this, so I hope this blog post comes in handy to anyone else who is curious and comes across this.<br /><br /><br /><br /><br /><br /><br /><br /><br /><br />